import complete.DefaultParsers.*

import java.io.ByteArrayInputStream
import java.util.Properties
import scala.collection.JavaConverters.*
import scala.util.{Failure, Success, Try}

ThisBuild / laserdiscRepoName := "sbt-laserdisc-defaults"

val ExpectedTemplateHeaderLine1 = "# ------------------ autogenerated file - do not edit -------------------"

val pluginRepoRootDir =
  sys.props.getOrElse("plugin.project.rootdir", sys.error("expected system property \"plugin.project.rootdir\" to be provided"))

lazy val root = (project in file("."))
  .enablePlugins(LaserDiscDefaultsPlugin)
  .settings(
    InputKey[Unit]("writeCurrentSBTVersion") := {

      val propsFile = (ThisBuild / baseDirectory).value / "project" / "build.properties"
      val content = s"""$ExpectedTemplateHeaderLine1
                       |sbt.version = ${sbtVersion.value}
                       |""".stripMargin
      IO.write(propsFile, content)
    },
    InputKey[Unit]("writeSBTVersion") := {

      val propsFile = (ThisBuild / baseDirectory).value / "project" / "build.properties"

      spaceDelimited("<arg>").parsed match {
        case versionStr :: Nil =>
          val content = s"""$ExpectedTemplateHeaderLine1
                           |sbt.version = $versionStr
                           |""".stripMargin

          IO.write(propsFile, content)
        case _ =>
          fail(s"writeSBTVersion expects 1 argument")
      }
    },
    InputKey[Unit]("verifySBTVersion") := {
      spaceDelimited("<arg>").parsed match {
        case versionStr :: Nil =>
          verifySBTVersion((ThisBuild / baseDirectory).value, versionStr)
        case _ =>
          fail(s"verifySBTVersion expects 1 argument")
      }
    },
    InputKey[Unit]("verifyCurrentSBTVersion") := {
      verifySBTVersion((ThisBuild / baseDirectory).value, sbtVersion.value)
    },
    InputKey[Unit]("verifyFileWasTemplated") := {

      spaceDelimited("<arg>").parsed match {
        case fileName :: Nil =>
          val sourceFile = file(pluginRepoRootDir) / fileName
          val actualFile = (ThisBuild / baseDirectory).value / fileName

          val sourceLines = readFile(sourceFile)
          val actualLines = readFile(actualFile)

          /* We _could_ template and compare, but this makes forces someone making minor changes
           * to the generated header update the tests too.  Let's keep this a little less brittle */
          val sourceContent = sourceLines.mkString("\n")
          val actualContent = actualLines.mkString("\n")

          if (actualLines.count(_.startsWith("###")) != 0) {
            fail(s"$actualFile should not have had any '###'-prefixed lines after templating. File content was:\n$actualContent")
          }

          if (actualLines.head != ExpectedTemplateHeaderLine1) {
            fail(s"$actualFile did not start with expected header.  File content was:\n$actualContent")
          }

          val sourceNonCommentLines = sourceLines.filterNot(_.matches("^#.*")).mkString("\n")
          val actualNonCommentLines = actualLines.filterNot(_.matches("^#.*")).mkString("\n")
          if (sourceNonCommentLines != actualNonCommentLines) {
            fail(
              s"""$actualFile does not appear to have been templated from $sourceFile
                 |
                 |Expected content (minus comments):
                 |---expected-begin---
                 |$sourceNonCommentLines
                 |---expected-end---
                 |
                 |But actual content was (minus comments):
                 |---actual-begin---
                 |$actualNonCommentLines
                 |---actual-end---
                 |""".stripMargin
            )
          }

          sLog.value.info(s"File $actualFile appears to have templated correctly from $sourceFile")

        case _ =>
          fail(s"verifyFileWasTemplated expects 1 argument")
      }

    }
  )

def verifySBTVersion(baseDir: File, expectedVersion: String): Unit = {
  val file  = baseDir / "project" / "build.properties"
  val bytes = IO.readBytes(file)

  val props = new Properties()
  props.load(new ByteArrayInputStream(bytes))

  val actualVersion = props.asScala.getOrElse("sbt.version", fail(s"Failed to load sbt.version from $file"))

  if (actualVersion != expectedVersion) {
    val content = new String(bytes)
    fail(s"""Wrong sbt.version found in ${file}
        |Expected: $expectedVersion
        |  actual: $actualVersion
        |""".stripMargin)
  }

}

def fail(msg: String) = throw new MessageOnlyException(msg)

def readFile(file: File): List[String] = Try {
  val src   = scala.io.Source.fromFile(file)
  val lines = src.getLines().toList
  src.close()
  lines
} match {
  case Failure(e) => throw new IllegalStateException(s"Failed to read file ${file.getAbsoluteFile}", e)
  case Success(v) => v
}
